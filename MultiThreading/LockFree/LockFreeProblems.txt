Lock-Free 알고리즘에서 중점적으로 처리해야 하는 문제

* ABA 문제
: 메모리에 변화가 가해졌는데 그걸 인지하지 못 하는 상황

1. 스레드 A : 특정 데이터를 읽기 위한 작업 진행
2. 스레드 B : 스레드 A에서 읽은 데이터를 갱신
3. 스레드 A : 다시 해당 데이터를 읽으려고 하는데 변화를 감지하지 못 함

ABA 문제가 Stack이나 Queue에서 발생하면 연결이 꼬일 수 있다(구조가 망가짐).

ABA 문제는 Lock-Free 알고리즘 뿐만 아니라 동시성 프로그래밍이라면 발생할 수 있는 문제이다.


* Use After Free
: 경합하고 있는 메모리를 삭제했는데 그걸 읽으려고 하는 문제

Stack 기준으로 경합이 발생했다고 가정하면...

1. 스레드 A에서 Head 복사
2. 스레드 B에서 Head 복사(경합 발생)
3. 스레드 A가 Head를 교체한 다음 데이터를 꺼내오고 이전 Head 삭제
4. 스레드 B에서 복사한 Head->Next를 읽으려고 하는 순간?

가상 메모리의 상태에 따라서 터질 수도 있고 안 터질 수도 있지만 분명히 문제가 되는 부분이다.

--------------------------------------------------

해결 방법

1. Double CAS
- ABA 문제는 막을 수 있으나
- Use After Free 문제를 막을 수는 없음

2. Split Reference Counts
- C++ Concurrency in Action에 나옴(internal, external)

3. Lock-Free 구조를 위한 메모리 풀 제작 + Double CAS 혼합
- 일단은 제일 Best
- 삭제를 안 하니 Use After Free 문제는 발생하지 않음
- 동시성 프로그래밍을 위해 Lock-Free 자료구조를 사용하면 프로그램 끝까지 살아있을 확률이 높음.
  - 프로그램 끝나는 순간까지 사용할 것이니 메모리 풀을 제작해도 큰 손해는 아님
