#include <bits/stdc++.h>
#include <WinSock2.h>

using namespace std;

// vscode 환경이 아닌 VC++에서 테스트할 것

// 짤막 요약
// 멀티바이트 자료형을 바이트 단위로 그대로 해석할 수 있으면 "빅 엔디안",
// 반대로 멀티바이트 자료형을 해석할 때 바이트 단위를 뒤집어서 봐야 한다면 "리틀 엔디안".

void endian_test_01()
{
    char chArr[4];
    chArr[0] = 0x12;
    chArr[1] = 0x34;
    chArr[2] = 0x56;
    chArr[3] = 0x78;

    unsigned int val = 0;
    char* pVal = (char*)&val;

    for (int i = 0; i < 4; i++)
    {
        *(pVal + i) = chArr[i];
    }

    std::cout << std::hex << "0x" << val << '\n';

    // 위 코드의 실행 결과는 엔디안 체계에 따라 다르게 나온다.
    // 
    // - 리틀 엔디안 : 0x78563412(10진수로는 2,018,915,346)
    // 
    // - 빅 엔디안 : 0x12345678(10진수로는 305,419,896)
    // 
    // 
    // !! 메모리 주소가 나열될 때 엔디안 체계에 따라 LSB(Least Significant Byte, 최하위 바이트)와 MSB(Most Significant Byte, 최상위 바이트)의 기준이 달라진다. !!
    // 
    // 리틀 엔디안 기준으로 보면 LSB는 가장 낮은 주소이고, MSB는 가장 높은 주소이다.
    // 
    // 4바이트 val의 메모리의 범위가 0x00 ~ 0x03이라고 했을 때, LSB는 0x00이고, MSB는 0x03이다.
    // 
    // 여기에 chArr의 값이 순차적으로 저장된다고 해보자.
    // 
    // 이때 chArr[0]은 메모리의 가장 낮은 주소인 LSB에 저장되고, 그 이후의 원소는 차례대로 높은 주소에 저장된다.
    // 
    //                   LSB                  MSB
    //                    ↓                    ↓
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 0x12 | 0x34 | 0x56 | 0x78 |
    // 
    // 리틀 엔디안은 저장된 바이트를 읽어 값으로 표현할 때 역순(LSB -> MSB)으로 해석하기에 결과는 0x78563412가 된다.
    // 
    // - 0x??'??'??'12 -> 0x??'??'34'12 -> 0x??'56'34'12 -> 0x78'56'34'12 (4바이트 자료형 기준)
    //     ↑        ↑       ↑        ↑       ↑        ↑       ↑        ↑
    //    MSB      LSB     MSB      LSB     MSB      LSB     MSB      LSB
    //    0x03    0x00     0x03    0x00     0x03    0x00     0x03    0x00
    // 
    // 
    // !! 우린 0x12345678을 통으로 저장한 것이 아닌 0x12, 0x34, 0x56, 0x78을 쪼개서 저장한 것이다(혼동주의). !!
    // 
    // 
    // 빅 엔디안 기준으로 보면 MSB는 가장 낮은 주소이고, LSB는 가장 높은 주소이다.
    // 
    // 4바이트 val의 메모리의 범위가 0x00 ~ 0x03이라고 했을 때, MSB는 0x00이고, LSB는 0x03이다.
    // 
    // 마찬가지로 chArr의 값이 순차적으로 저장된다고 해보자.
    // 
    // 이때 chArr[0]은 메모리의 가장 낮은 순서인 MSB에 저장되고, 그 이후의 원소는 차례대로 높은 주소에 저장된다.
    // 
    //                   MSB                  LSB
    //                    ↓                    ↓
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 0x12 | 0x34 | 0x56 | 0x78 |
    // 
    // 빅 엔디안은 저장된 바이트를 읽어 값으로 표현할 때 정순(MSB -> LSB)으로 해석하기에 결과는 0x12345678이 된다.
    // 
    // - 0x12'??'??'?? -> 0x12'34'??'?? -> 0x12'34'56'?? -> 0x12'34'56'78
    //     ↑        ↑       ↑        ↑       ↑        ↑       ↑        ↑
    //    MSB      LSB     MSB      LSB     MSB      LSB     MSB      LSB
    //    0x00    0x03     0x00    0x03     0x00    0x03     0x00    0x03
    // 
    // 
    // !! 리틀 엔디안이든 빅 엔디안이든 데이터를 읽을 때는 가장 낮은 주소에서 가장 높은 주소로 읽어서 값을 해석한다. !!
    // 
    // - 리틀 엔디안 : 가장 낮은 메모리에 LSB(최하위 바이트) 값이, 가장 높은 주소에 MSB(최상위 바이트) 값이 저장됨.
    // 
    // - 빅 엔디안 : 가장 낮은 메모리에 MSB(최상위 바이트) 값이, 가장 높은 주소에 LSB(최하위 바이트) 값이 저장됨.
    // 
    // !! 정 모르겠으면 리틀 엔디안은 역순, 빅 엔디안은 정순이라고 외워라. !!
    // 
    // !! 리틀 엔디안이든 빅 엔디안이든 메모리의 시작 주소는 0x00으로 동일하다. !!
    //
    // !! 그냥 단순하게 바이트 단위 하나하나로 인식하면 안 된다(char[n]이 아님). !!
    // !! 핵심은 멀티바이트 자료형을 구성하는 바이트 뭉치를 어떻게 해석하느냐에 있다. !!
}

void endian_test_02()
{
    unsigned int val = 0x12345678;
    char* ptr = (char*)&val;

    cout << std::hex << "0x" << (unsigned int)*ptr << '\n';

    // 위 코드도 엔디안 체계에 따라 실행 결과가 다르게 나온다.
    // 
    // - 리틀 엔디안 : 0x78
    // 
    // - 빅 엔디안 : 0x12
    // 
    // !! 메모리 시작 주소는 둘 다 0x00이다. !!
    // 
    // 
    // 리틀 엔디안 시스템에서는 다음과 같이 저장된다.
    // 
    //                   LSB                  MSB
    //                    ↓                    ↓
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 0x78 | 0x56 | 0x34 | 0x12 |
    // 
    // 시작 주소는 0x00이니, 이 주소가 가지는 값을 1바이트만 읽으면 0x78이다.
    // 
    // 리틀 엔디안 체계에서 4바이트 값을 통으로 읽는다면 바이트를 역순(LSB -> MSB)로 해석하기에 결과는 0x12345678이 된다.
    // 
    // - 0x??'??'??'78 -> 0x??'??'56'78 -> 0x??'34'56'78 -> 0x12'34'56'78 (4바이트 자료형 기준)
    //     ↑        ↑       ↑        ↑       ↑        ↑       ↑        ↑
    //    MSB      LSB     MSB      LSB     MSB      LSB     MSB      LSB
    //    0x03    0x00     0x03    0x00     0x03    0x00     0x03    0x00
    // 
    // 
    // 빅 엔디안 시스템에서는 다음과 같이 저장된다.
    // 
    //                   MSB                  LSB
    //                    ↓                    ↓
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 0x12 | 0x34 | 0x56 | 0x78 |
    // 
    // 시작 주소는 0x00이니, 이 주소가 가지는 값을 1바이트만 읽으면 0x12이다.
    // 
    // 빅 엔디안 체계에서 4바이트 값을 통으로 읽는다면 바이트를 정순(MSB -> LSB)로 해석하기에 결과는 0x12345678이 된다.
    // 
    // - 0x12'??'??'?? -> 0x12'34'??'?? -> 0x12'34'56'?? -> 0x12'34'56'78
    //     ↑        ↑       ↑        ↑       ↑        ↑       ↑        ↑
    //    MSB      LSB     MSB      LSB     MSB      LSB     MSB      LSB
    //    0x00    0x03     0x00    0x03     0x00    0x03     0x00    0x03
    // 
    // 
    // !! 4바이트를 "1바이트씩 주소 단위로 끊어서" 읽는 것과 4바이트를 "자료형 통째로" 읽는 건 다르게 봐야 한다. !!
    // 
    // !! 메모리 주소 0x00, 0x01, 0x02, 0x03이 있을 때 여기에 4바이트 자료형이 할당되어도 리틀 엔디안이든 빅 엔디안이든 시작 주소는 0x00으로 동일하니 혼동하지 말자. !!
    // !! 리틀 엔디안과 빅 엔디안의 차이는 값이 저장되는 형태와 값을 읽는 형태에 있을 뿐이지 자료형의 시작 주소에는 영향을 미치지 않는다. !!
    // 
    // !! 리틀 엔디안과 빅 엔디안은 멀티바이트 데이터를 메모리에 저장하는 순서와 이를 읽는 순서에 영향을 미친다. !!
    // !! 하지만 단일 바이트 단위로 저장된 데이터에 대해서는 영향을 미치지 않는다. !!
}

void endian_test_03()
{
    // inet_addr()는 문자열 IP 주소를 네트워크 바이트 순서의 4바이트 정수형 데이터로 변환함.
    unsigned long netVal = inet_addr("127.0.0.1");
    unsigned char chArr[4];

    // 네트워크에서 데이터를 받았다고 가정(그대로 복사)
    memcpy(chArr, &netVal, sizeof(chArr));

    // "127.0.0.1"을 출력
    std::cout << std::dec << (int)chArr[0] << "." << (int)chArr[1] << "." << (int)chArr[2] << "." << (int)chArr[3] << '\n';

    // 빅 엔디안의 데이터가 리틀 엔디안 환경으로 온다고 해도 첫 예시의 바이트 당 데이터 복사 과정을 이해하면 무슨 내용인지 쉽게 이해할 수 있다.
    // 
    // 네트워크 바이트 오더(빅 엔디안)로 전송된 데이터가 char 배열에 복사될 때, 데이터는 바이트 단위로 그대로 복사된다.
    //
    // 즉, 네트워크 바이트 오더로 받은 데이터를 char 배열에 복사하면 별다른 추가 처리 없이 그대로 사용할 수 있다.
    // 
    // !! 이는 char가 1바이트이기 때문에 성립하는 것이다. !!
    // 
    // !! char가 아닌 멀티바이트 정수형(int, short 등)으로 사용하고자 할 때는 반드시 호스트 바이트 오더로 정렬해주는 함수를 사용해서 써야 한다. !!
    //
    // !! 단순 char 배열과 멀티바이트 자료형을 구성하는 바이트 뭉치는 다르게 봐야 한다. !!
    // 
    // 
    // 1) 리틀 엔디안 환경에서 배열 구성
    // 
    // 리틀 엔디안 환경에서 구성한 배열 char[4]{ 'A', 'B', 'C', 'D' }를 빅 엔디안 환경에 보냈어도 데이터는 원래 순서를 그대로 유지한다.
    // 
    // 리틀 엔디안 환경의 char[4]{ 'A', 'B', 'C', 'D' }, 시작 주소는 0x00.
    // 
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 'A'  | 'B'  | 'C'  | 'D'  |
    // 
    // 2) 데이터 전송
    // 
    // 데이터를 네트워크로 전송할 때는 바이트 단위이기 때문에 'A'(0x41), 'B'(0x42), 'C'(0x43), 'D'(0x44)를 전송한다.
    // 
    // 3) 빅 엔디안 환경에서 데이터 수신
    // 
    // 빅 엔디안 환경에서 데이터를 수신하면 바이트 단위로 동일한 데이터가 도착한다.
    // 
    // 빅 엔디안 환경의 char[4]{ 'A', 'B', 'C', 'D' }, 시작 주소는 0x00.
    // 
    // Memory Addr  :  | 0x00 | 0x01 | 0x02 | 0x03 |
    // Stored Value :  | 'A'  | 'B'  | 'C'  | 'D'  |
    // 
    // !! 엔디안 방식은 멀티바이트 자료형의 값을 해석할 때 영향을 미치는 요소이지, 단일 바이트로 구성된 배열에는 영향을 미치지 않는다. !!
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    endian_test_01();
    endian_test_02();
    endian_test_03();

    return 0;
}
